call.invalid.io=Calling a method with %s effect from a context limited to %s effects.
annotations.conflicts=A method may only have one effect annotation from @IO and @AlwaysNoIO
override.effect.invalid=%s in %s cannot override %s in %s; a method override may only be @IO if it overrides an @IO method.
override.effect.invalid.polymorphic=%s in %s cannot override %s in %s; a method override may only be @PolyIOEffect if it overrides a @PolyIOEffect method.
override.effect.invalid.nonio=%s in %s cannot override %s in %s; a method override may only be @IO if it overrides an @IO method (overriding non-IO instantiation of supertype).
override.effect.warning.inheritance=%s in %s overrides a method with @IO effect (%s in %s) and another method with an @AlwaysNoIO effect (%s in %s).  This is discouraged.
polymorphism.invalid=Only @PolyIOType types may have @PolyIOEffect methods.
inheritance.polymorphic.invalid=An effect-polymorphic type may only inherit from another effect-polymorphic type (%s extends/implements %s).
effects.redundant.iotype=This method is annotated @IOEffect, which is redundant because the enclosing type is @IOType.
constructor.call.invalid=Calling a constructor with %s effect from a context limited to %s effects. 